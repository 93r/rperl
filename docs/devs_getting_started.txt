# RPerl System Developers
# Getting Started, A How-To Guide
# Last Updated 20160723 2016.205

Welcome to RPerl, and thank you for your interest in joining the RPerl system developers!

If you would like to create software libraries and applications (AKA "programs" or "apps") to be utilized by end-users, then this is not the correct document for you.
Instead, please read the book Learning RPerl and join the RPerl application developers:

Learning RPerl
http://rperl.org/learning_rperl.html

RPerl App Devs Group
https://www.facebook.com/groups/1551887621787018

RPerl App Devs Intake Board
https://trello.com/b/XmmPJQJj/austin-pm-rperl-app-devs-intake

If, however, you are interested in contributing to the development of the RPerl compiler itself, then you are in the right place!
This document will take you through the steps required to create a new RPerl operator, which will help you start learning the basic architecture of RPerl.


STEP 0.  Complete RPerl Developers Intake Process

The intake process for RPerl system developers is the same as used for RPerl application developers.
If you already have a Trello account, then please follow the URL for Trello above.
If you have a Facebook account, then please submit a request to join at the URL below:

RPerl System Devs Group
https://www.facebook.com/groups/999476090136466

If you have neither a Trello nor Facebook account, then please send an e-mail with the subject line "RPerl System Devs" to the address below (remove NOSPAM):

william.braswell at NOSPAM.autoparallel.com


STEP 1.  Choose An Operator

When you have completed the intake process and are ready to start contributing, then the first main step is to choose an operator which has not yet been implemented.
Start by opening up the URL below to Learning RPerl section 2.1.11, then perform a browser search for the string "Coming Soon":

http://rperl.org/learning_rperl.html#Section_2.1.11%3A_Arithmetic_Operators

You should be able to choose among most or all of the "Coming Soon" operators, although it is possible that another RPerl system developer is currently working on your first choice operator, so be sure to check with the lead developers on Trello and Facebook before finalizing your selection.

For this example, we will choose the absolute value operator 'abs', implemented by our first authorized RPerl system developer, Pablo Rodríguez González. 
Imagine that you are Pablo, and this is the process you are going through to implement the 'abs' operator.
Technically, absolute value is a "named operator", as found in the RPerl grammar file with the token OP01_NAMED_SCOLON:

https://github.com/wbraswell/rperl/blob/master/lib/RPerl/Grammar.eyp

By searching for OP01_NAMED_SCOLON at the URL above, you can see a long list showing that all of Perl's named operators are already enabled, but in the grammar only.
Also, search for the token OP10_NAMED_UNARY_SCOLON to see all the "named unary operators", which are a type of named operator that accept exactly one argument.
Many of the remaining non-named operators are already fully implemented, whereas most of the named operators are not yet implemented outside of the grammar.
To see a list of all operators which are already (at least partially) implemented, view the URLs below:

https://github.com/wbraswell/rperl/blob/master/lib/rperloperations.pm
https://github.com/wbraswell/rperl/tree/master/lib/RPerl/Operation/Expression/Operator/Named
https://github.com/wbraswell/rperl/tree/master/lib/RPerl/Operation/Expression/Operator/NamedUnary

Some of the operators listed in the URL above are only partially implemented, in that they only support PERLOPS_PERLTYPES mode (see step 2 below for modes explanation), whereas we need both PERLOPS_PERLTYPES mode as well as CPPOPS_CPPTYPES mode implemented for each operator.  Thus, any operators which have a stub subroutine for CPPOPS_CPPTYPES mode are eligible for you to choose, simply search for anywhere the string 'DUMMY_SOURCE_CODE' appears inside a subroutine named ast_to_cpp__generate__CPPOPS_CPPTYPES().


STEP 2.  Study Similar Operators

From an RPerl system developer's point of view, absolute value is a named operator, as specified in the RPerl grammar and overall architecture.
However, absolute value is included in the "Arithmetic Operators" section of Learning RPerl, for easier understanding by RPerl application developers.
There is no "Named Operators" section of Learning RPerl, because it would be a long unorganized list which is not easy to grasp or utilize for reference.
Again, absolute value is technically not an "Arithmetic Operator" like the '+' (addition) or '*' (multiplication) operators, even though they are all used for math.

Thus, before implementing absolute value, you should study the existing implementations of other named operators at the URL below:

https://github.com/wbraswell/rperl/tree/master/lib/RPerl/Operation/Expression/Operator/Named

If you have instead chosen to implement a named unary operator, they may be found here:

https://github.com/wbraswell/rperl/tree/master/lib/RPerl/Operation/Expression/Operator/NamedUnary 

Each operator's Perl module file in the 2 URLs above has 3 primary subroutines, which correspond to RPerl's 3 primary modes, and each generate source code as output:

ast_to_cpp__generate__PERLOPS_PERLTYPES()
ast_to_cpp__generate__CPPOPS_PERLTYPES()
ast_to_cpp__generate__CPPOPS_CPPTYPES()

The corresponding 3 primary modes of RPerl are:

0.  Perl Operations & Perl Data Types, AKA "slow mode"   or "interpreted mode" or "test mode" or "normal Perl mode", runs via normal dynamic Perl interpreter, 1x speed
1.  C++  Operations & Perl Data Types, AKA "medium mode" or "mixed mode", runs via combination of dynamic Perl interpreter & static C++ compiler, approx 7x - 10x speed 
2.  C++  Operations & C++  Data Types, AKA "fast mode"   or "compiled mode", runs via static C++ compiler, approx 100x - 400x speed

Each of these 3 code generation subroutines accepts as input an RPerl abstract syntax tree (AST), which is a Perl object (blessed hashref) data structure generated by lexing and parsing some RPerl application source code.  Because all named operators are combined together into just 2 groups in the RPerl grammar (named and named unary), they require special handling in the RPerl architecture.  All RPerl code generation subroutines use the same names as these 3 subroutines, and most RPerl code generation subroutines accept their AST argument in the $self variable as part of RPerl's object-oriented architecture.  However, the special handling for named operators causes use to receive an artificially-generated dummy object into the $self variable, while our real AST object is received into the $operator_named variable.

All RPerl code generation subroutines also accept as their final input argument the globally-utilized $modes variable, which is a string_hashref data structure containing the current RPerl modes, symbol table, and a number of other possible flags or values required for proper RPerl functionality.  The $modes variable should be passed as the final argument to all RPerl code generation subroutines, as well as many (or perhaps most) other RPerl system subroutines.

Each of the subroutines generates as output a source group variable, which is another Perl string_hashref data structure containing all generated source code.  In the PERLOPS_PERLTYPES code generation subroutines, this return value variable is named $rperl_source group, and in the other 2 modes it is named $cpp_source_group.  Each key in the source group hashes is the all-uppercase equivalent of the generated source code file suffix, so in PERLOPS_PERLTYPES mode the $rperl_source_group hash variable only contains the key 'PMC' ("Perl Module Compiled"), and all generated Perl source code is stored within the corresponding 'PMC' hash value, which could eventually be saved to a file ending with the suffix '.pmc'.  The generated '.pmc' file should be exactly equivalent to the original '.pm' input file, not counting code comments, which is why PERLOPS_PERLTYPES is also called "test mode", as the original RPerl input source code is completely parsed and then generated back into the matching original form as a test of the RPerl grammar, etc.

In CPPOPS_PERLTYPES and CPPOPS_CPPTYPES modes, the $cpp_source_group hash variable contains at least the 'CPP' key which can be saved to a '.cpp' output C++ source code file.  The $cpp_source_group hash may also contain 'H' and 'PMC' keys, although most named operators will only need to output into the 'CPP' source code.

The PERLOPS_PERLTYPES subroutine is implemented first for all operators, and in the cases where an operator's Perl module file has already been created, there should already be a completed ast_to_cpp__generate__PERLOPS_PERLTYPES() subroutine present.  The CPPOPS_PERLTYPES mode is currently not implemented for most RPerl operators, and will be left as a stub containing "DUMMY_SOURCE_CODE" until a later version of RPerl.  The CPPOPS_CPPTYPES mode is the main focus of our RPerl system development efforts, because it offers the most speed benefits by far.  Do not attempt to implement any CPPOPS_PERLTYPES code whatsoever, only the other 2 modes.


STEP 3.  Make A Fork On GitHub

If you did not already have a GitHub account, then you should have created one during step 0.
Now you will create your own fork of RPerl on GitHub, which means you will have your own new copy of RPerl in a GitHub repository (AKA "repo").
This forked repository will contain all your new code changes, without accidentally breaking the main RPerl repo.

While logged in to your GitHub account, visit the URL below and select the "Fork" button in the upper-right, then follow the instructions:
https://github.com/wbraswell/rperl

You may optionally create as many branches as you like within your new forked repository, or you can stay at 1 branch in the new repo to keep it simple.
In step 7, you will carefully merge your new code back in to the main RPerl repo.


STEP 4.  Create The Operator's Perl Module File

You will be creating a new file named 'lib/RPerl/Operation/Expression/Operator/Named/AbsoluteValue.pm' which will contain most of your new code.

To find a file which you can use as a starting template, you start by looking in the directory containing all named operators:
https://github.com/wbraswell/rperl/tree/master/lib/RPerl/Operation/Expression/Operator/Named

You see that RPerl support for the 'chomp' operator only allows the low-magic 'chomp VARIABLE' syntax, which is similar to the 'abs VALUE' syntax you need to support:
https://github.com/wbraswell/rperl/blob/master/lib/RPerl/Operation/Expression/Operator/Named/Chomp.pm

Thus, you create a copy of the "Chomp.pm" file and rename it to "AbsoluteValue.pm", then begin changing anywhere specific to 'chomp' to become 'abs', etc.

Follow the URL below to see Pablo's first commit of the Perl module file, which includes support for PERLOPS_PERLTYPES mode only:
https://github.com/wbraswell/rperl/blob/4d997f91a52a34d8f4fa1a47830bc246aacd736e/lib/RPerl/Operation/Expression/Operator/Named/AbsoluteValue.pm

But wait!  While you were working, a change was made to the RPerl grammar in the main RPerl repo, so we have to update the grammar rule serial numbers as seen here:
https://github.com/wbraswell/rperl/commit/9d6b53f447a370869fb32835d1266a4f7f825f2e#diff-fc9b0cbe0168b9b1c7ec7026ea8175efL9

Hopefully you won't have a grammar change happen while you are working on your own operator, but as we can see it is definitely possible.

Next, you have noticed that you need to implement CPPOPS_CPPTYPES, because the 'chomp' operator only supports PERLOPS_PERLTYPES.
The most similar reference file with CPPOPS_CPPTYPES already implemented is the named unary 'scalar' operator:
https://github.com/wbraswell/rperl/blob/master/lib/RPerl/Operation/Expression/Operator/NamedUnary/Scalar.pm

So you copy the ast_to_cpp__generate__CPPOPS_CPPTYPES() subroutine from "Scalar.pm" into your new "AbsoluteValue.pm" and modify as needed:
https://github.com/wbraswell/rperl/blob/99f74bd40d0214713f92c4efaac746f89d0821d6/lib/RPerl/Operation/Expression/Operator/Named/AbsoluteValue.pm

And we forgot to change the PERLOPS_PERLTYPES error code to the correct format for CPPOPS_CPPTYPES, so you fix that:
https://github.com/wbraswell/rperl/commit/1350e0bbe8a21659faa4798f536e78fafe720034

Next, you realize we want our generated C++ code to match the original RPerl input source code as closely as possible, which means we want to generate 'abs' in C++ instead of 'std::abs', which is achieved by removing 'std::' from "AbsoluteValue.pm" and adding a C++ '#define' statement to the "rperloperations.h" file:
https://github.com/wbraswell/rperl/commit/3153a85327dd7116eeb757692c05d2ec077ada2d#diff-fc9b0cbe0168b9b1c7ec7026ea8175efL111
https://github.com/wbraswell/rperl/commit/3153a85327dd7116eeb757692c05d2ec077ada2d#diff-1e5c0f27b0c43112d615cf4e6b903899R16

Oops, another bug!  We can not add extra parentheses where there were none required, so they must be removed:
https://github.com/wbraswell/rperl/commit/c893b70e9e047c6a7a0f9b1d9029c2f5195af53f#diff-fc9b0cbe0168b9b1c7ec7026ea8175efL114

All RPerl source code files should be auto-formatted using the Perltidy utility:
http://perltidy.sourceforge.net

It is important that you are using the official RPerl formatting configuration file, contained within the Perltidy run commands ("RC") file:
https://github.com/wbraswell/lampuniversity.org/blob/master/docs/.perltidyrc

When formatted with the correct Perltidy RC file, you see some minor cosmetic changes:
https://github.com/wbraswell/rperl/commit/272a7ffc7a515839803168dd696bd1ae2711d06d#diff-fc9b0cbe0168b9b1c7ec7026ea8175efL21

Last but not least, you forgot to update the 'abs' calling convention in the Perl module file's "DOCUMENTATION" section:
NEED LINK HERE

That's it!  Your new Perl module file is now complete.

As you can see from the multiple URLs in this step, it took multiple commits to reach this point.
The new "AbsoluteValue.pm" file was merged into the main RPerl repo before CPPOPS_CPPTYPES was implemented and before all bugs were worked out.
It is fine if it takes you several commits in your forked repo to complete work on your new operator, and hopefully you will NOT merge your code into the main RPerl repo before all the work is done and all the bugs are fixed.

To see the full, real history of this file, follow the URL below:
https://github.com/wbraswell/rperl/commits/master/lib/RPerl/Operation/Expression/Operator/Named/AbsoluteValue.pm

To view the latest copy of this Perl module file, follow this URL:
https://github.com/wbraswell/rperl/blob/master/lib/RPerl/Operation/Expression/Operator/Named/AbsoluteValue.pm


STEP 5.  Update Appendant Files

Then insert a line 'use RPerl::Operation::Expression::Operator::Arithmetic::AbsoluteValue;' in the rperloperations.pm file:
https://github.com/wbraswell/rperl/blob/master/lib/rperloperations.pm

# DEV NOTE, CORRELATION #rp020: upon adding new named op file lib/RPerl/Operation/Expression/Operator/Named/* also add in Grammar.eyp, Named.pm, and rperloperations.*
https://github.com/wbraswell/rperl/blob/master/lib/RPerl/Grammar.eyp
https://github.com/wbraswell/rperl/blob/master/lib/RPerl/Operation/Expression/Operator/Named.pm
https://github.com/wbraswell/rperl/blob/master/lib/rperloperations.h
https://github.com/wbraswell/rperl/blob/master/lib/rperloperations.pm

what about recompile grammar???
./script/development/grammar_recompile.sh


STEP 6.  Create Tests

And (I believe) lastly, create a new test directory 'lib/RPerl/Test/Operator01AbsoluteValue' containing test files for the `abs` operator, and of course run the test suite to make sure all new tests (and current tests) pass.  You can see the other arithmetic operator tests as examples here:
https://github.com/wbraswell/rperl/tree/master/lib/RPerl/Test

Q:  Second, there is only one file under lib/RPerl/Test, because I think "bad" tests are included in the "bad" files located in lib/RPerl/Test/Operator01Named
A:  I will help you sort out the tests when I have a chance to look at your new code, probably tonight or tomorrow.
You still need to create new bad tests in "lib/RPerl/Test/Operator01AbsoluteValue", tests which specifically cause errors when using the 'abs' operator, such as passing 0 or 2 arguments to abs, or passing invalid arguments, or other grammar errors like omitting a semicolon after properly calling abs.  I always plan to create at least a half dozen failing (bad) tests and 2 or 3 passing (good) tests for each new operator.

Q:  Real behaviour is not tested. I mean, abs correctness is not tested. Well RPerl is just a compiler so we test the correct "translation" but what about the real functionality?
A:  The real functionality of the PERLOPS_PERLTYPES mode is currently tested via the EXECUTE_SUCCESS preprocessor tag inside each bad and good test file.  I will soon be adding auto-compile support for the tests to also check CPPOPS_CPPTYPES functionality as well.


STEP 7.  Make A Pull Request On GitHub

Before submitting a pull request on GitHub, please make sure your development branch or fork is up to date and compatible with the latest GitHub master branch.
