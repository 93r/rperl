# RPerl System Developers
# Getting Started, A How-To Guide
# Last Updated 20160723 2016.205

Welcome to RPerl, and thank you for your interest in joining the RPerl system developers!

If you would like to create software libraries and applications (AKA "programs" or "apps") to be utilized by end-users, then this is not the correct document for you.
Instead, please read the book Learning RPerl and join the RPerl application developers:

Learning RPerl
http://rperl.org/learning_rperl.html

RPerl App Devs Group
https://www.facebook.com/groups/1551887621787018

RPerl App Devs Intake Board
https://trello.com/b/XmmPJQJj/austin-pm-rperl-app-devs-intake

If, however, you are interested in contributing to the development of the RPerl compiler itself, then you are in the right place!
This document will take you through the steps required to create a new RPerl operator, which will help you start learning the basic architecture of RPerl.


STEP 0.  Complete RPerl Developers Intake Process

The intake process for RPerl system developers is the same as used for RPerl application developers.
If you already have a Trello account, then please follow the URL for Trello above.
If you have a Facebook account, then please submit a request to join at the URL below:

RPerl System Devs Group
https://www.facebook.com/groups/999476090136466

If you have neither a Trello nor Facebook account, then please send an e-mail with the subject line "RPerl System Devs" to the address below (remove NOSPAM):

william.braswell at NOSPAM.autoparallel.com


STEP 1.  Choose An Operator

When you have completed the intake process and are ready to start contributing, then the first main step is to choose an operator which has not yet been implemented.
Start by opening up the URL below to Learning RPerl section 2.1.11, then perform a browser search for the string "Coming Soon":

http://rperl.org/learning_rperl.html#Section_2.1.11%3A_Arithmetic_Operators

You should be able to choose among most or all of the "Coming Soon" operators, although it is possible that another RPerl system developer is currently working on your first choice operator, so be sure to check with the lead developers on Trello and Facebook before finalizing your selection.

For this example, we will choose the absolute value operator 'abs', implemented by our first authorized RPerl system developer, Pablo Rodríguez González. 
Imagine that you are Pablo, and this is the process you are going through to implement the 'abs' operator.
Technically, absolute value is a "named operator", as found in the RPerl grammar file with the token OP01_NAMED_SCOLON:

https://github.com/wbraswell/rperl/blob/master/lib/RPerl/Grammar.eyp

By searching for OP01_NAMED_SCOLON at the URL above, you can see a long list showing that all of Perl's named operators are already enabled, but in the grammar only.
Also, search for the token OP10_NAMED_UNARY_SCOLON to see all the "named unary operators", which are a type of named operator that accept exactly one argument.
Many of the remaining non-named operators are already fully implemented, whereas most of the named operators are not yet implemented outside of the grammar.
To see a list of all operators which are already (at least partially) implemented, view the URL below:

https://github.com/wbraswell/rperl/blob/master/lib/rperloperations.pm

Some of the operators listed in the URL above are only partially implemented in PERLOPS_PERLTYPES mode only (see step 2 below for modes explanation), whereas we need both PERLOPS_PERLTYPES mode as well as CPPOPS_CPPTYPES mode implemented for each operator.  Thus, any operators which have a stub subroutine for CPPOPS_CPPTYPES mode are eligible for you to choose, simply search for anywhere the string 'DUMMY_SOURCE_CODE' appears inside a subroutine named ast_to_cpp__generate__CPPOPS_CPPTYPES().


STEP 2.  Study Similar Operators

From an RPerl system developer's point of view, absolute value is a named operator, as specified in the RPerl grammar and overall architecture.
However, absolute value is included in the "Arithmetic Operators" section of Learning RPerl, for easier understanding by RPerl application developers.
There is no "Named Operators" section of Learning RPerl, because it would be a long unorganized list which is not easy to grasp or utilize for reference.
Again, absolute value is technically not an "Arithmetic Operator" like the '+' (addition) or '*' (multiplication) operators, even though they are all used for math.

Thus, before implementing absolute value, you should study the existing implementations of other named operators at the URL below:

https://github.com/wbraswell/rperl/tree/master/lib/RPerl/Operation/Expression/Operator/Named

If you have instead chosen to implement a named unary operator, they may be found here:

https://github.com/wbraswell/rperl/tree/master/lib/RPerl/Operation/Expression/Operator/NamedUnary 

Each operator's Perl module file in the 2 URLs above has 3 primary subroutines, which correspond to RPerl's 3 primary modes, and each generate source code as output:

ast_to_cpp__generate__PERLOPS_PERLTYPES()
ast_to_cpp__generate__CPPOPS_PERLTYPES()
ast_to_cpp__generate__CPPOPS_CPPTYPES()

The corresponding 3 primary modes of RPerl are:

0.  Perl Operations & Perl Data Types, AKA "slow mode"   or "interpreted mode" or "test mode" or "normal Perl mode", runs via normal dynamic Perl interpreter, 1x speed
1.  C++  Operations & Perl Data Types, AKA "medium mode" or "mixed mode", runs via combination of dynamic Perl interpreter & static C++ compiler, approx 7x - 10x speed 
2.  C++  Operations & C++  Data Types, AKA "fast mode"   or "compiled mode", runs via static C++ compiler, approx 100x - 400x speed

Each of these 3 code generation subroutines accepts as input an RPerl abstract syntax tree (AST), which is a Perl object (blessed hashref) data structure generated by lexing and parsing some RPerl application source code.  Because all named operators are combined together into just 2 groups in the RPerl grammar (named and named unary), they require special handling in the RPerl architecture.  All RPerl code generation subroutines use the same names as these 3 subroutines, and most RPerl code generation subroutines accept their AST argument in the $self variable as part of RPerl's object-oriented architecture.  However, the special handling for named operators causes use to receive an artificially-generated dummy object into the $self variable, while our real AST object is received into the $operator_named variable.

All RPerl code generation subroutines also accept as their final input argument the globally-utilized $modes variable, which is a string_hashref data structure containing the current RPerl modes, symbol table, and a number of other possible flags or values required for proper RPerl functionality.  The $modes variable should be passed as the final argument to all RPerl code generation subroutines, as well as many (or perhaps most) other RPerl system subroutines.

Each of the subroutines generates as output a source group variable, which is another Perl string_hashref data structure containing all generated source code.  In the PERLOPS_PERLTYPES code generation subroutines, this return value variable is named $rperl_source group, and in the other 2 modes it is named $cpp_source_group.  Each key in the source group hashes is the all-uppercase equivalent of the generated source code file suffix, so in PERLOPS_PERLTYPES mode the $rperl_source_group hash variable only contains the key 'PMC' ("Perl Module Compiled"), and all generated Perl source code is stored within the corresponding 'PMC' hash value, which could eventually be saved to a file ending with the suffix '.pmc'.  The generated '.pmc' file should be exactly equivalent to the original '.pm' input file, not counting code comments, which is why PERLOPS_PERLTYPES is also called "test mode", as the original RPerl input source code is completely parsed and then generated back into the matching original form as a test of the RPerl grammar, etc.

In CPPOPS_PERLTYPES and CPPOPS_CPPTYPES modes, the $cpp_source_group hash variable contains at least the 'CPP' key which can be saved to a '.cpp' output C++ source code file.  The $cpp_source_group hash may also contain 'H' and 'PMC' keys, although most named operators will only need to output into the 'CPP' source code.

The PERLOPS_PERLTYPES subroutine is implemented first for all operators, and in the cases where an operator's Perl module file has already been created, there should already be a completed ast_to_cpp__generate__PERLOPS_PERLTYPES() subroutine present.  The CPPOPS_PERLTYPES mode is currently not implemented for most RPerl operators, and will be left as a stub containing "DUMMY_SOURCE_CODE" until a later version of RPerl.  The CPPOPS_CPPTYPES mode is the main focus of our RPerl system development efforts, because it offers the most speed benefits by far.  Do not attempt to implement any CPPOPS_PERLTYPES code whatsoever, only the other 2 modes.



START HERE: continue fleshing out document below
START HERE: continue fleshing out document below
START HERE: continue fleshing out document below



STEP 3.  Make A Fork On Github

Q:  Third, I've made a fork, and a feature branch in order to do a pull request. Is this the prefered way for contributions?
A:  Yes it is best for now to create your own fork and then do pull requests.


STEP 4.  Create Operator's Perl Module File

You will be creating a new file named 'lib/RPerl/Operation/Expression/Operator/Arithmetic/AbsoluteValue.pm'  NEED FIX PATH FROM Arithmetic/ TO Named/

You should use one of the existing Arithmetic operator .pm files as the template for your work.

Q:  First, abs is listed as a named operator in Grammar.eyp so instead of using the "arithmetic" path I've used the "named" path. Is this ok?
A:  Named and arithmetic operators are kinda the same, kinda different.  I will need to investigate further to answer this question.
You are correct to categorize 'abs' as a named operator, that is technically and grammatically correct.  The only special aspect of this particular operator is that it will be listed with the arithmetic operators in the Learning RPerl book, because named operators don't have their own section in the book.

Q:  The CPP part is not working, the CPP code is just a DUMMY comment. Should I complete this part?
A:  Yes you should definitely implement the CPPOPS_CPPTYPES code which is currently just a DUMMY stub.  You can ignore the CPPOPS_PERLTYPES code stub for now.

what about named unary ops???
https://github.com/wbraswell/rperl/blob/master/lib/RPerl/Operation/Expression/Operator/NamedUnary.pm

be sure to format!
https://github.com/wbraswell/lampuniversity.org/blob/master/docs/.perltidyrc


STEP 5.  Update Appendant Files

Then insert a line 'use RPerl::Operation::Expression::Operator::Arithmetic::AbsoluteValue;' in the rperloperations.pm file:
https://github.com/wbraswell/rperl/blob/master/lib/rperloperations.pm

# DEV NOTE, CORRELATION #rp020: upon adding new named op file lib/RPerl/Operation/Expression/Operator/Named/* also add in Grammar.eyp, Named.pm, and rperloperations.*
https://github.com/wbraswell/rperl/blob/master/lib/RPerl/Grammar.eyp
https://github.com/wbraswell/rperl/blob/master/lib/RPerl/Operation/Expression/Operator/Named.pm
https://github.com/wbraswell/rperl/blob/master/lib/rperloperations.h
https://github.com/wbraswell/rperl/blob/master/lib/rperloperations.pm

what about recompile grammar???
./script/development/grammar_recompile.sh


STEP 6.  Create Tests

And (I believe) lastly, create a new test directory 'lib/RPerl/Test/Operator01AbsoluteValue' containing test files for the `abs` operator, and of course run the test suite to make sure all new tests (and current tests) pass.  You can see the other arithmetic operator tests as examples here:
https://github.com/wbraswell/rperl/tree/master/lib/RPerl/Test

Q:  Second, there is only one file under lib/RPerl/Test, because I think "bad" tests are included in the "bad" files located in lib/RPerl/Test/Operator01Named
A:  I will help you sort out the tests when I have a chance to look at your new code, probably tonight or tomorrow.
You still need to create new bad tests in "lib/RPerl/Test/Operator01AbsoluteValue", tests which specifically cause errors when using the 'abs' operator, such as passing 0 or 2 arguments to abs, or passing invalid arguments, or other grammar errors like omitting a semicolon after properly calling abs.  I always plan to create at least a half dozen failing (bad) tests and 2 or 3 passing (good) tests for each new operator.

Q:  Real behaviour is not tested. I mean, abs correctness is not tested. Well RPerl is just a compiler so we test the correct "translation" but what about the real functionality?
A:  The real functionality of the PERLOPS_PERLTYPES mode is currently tested via the EXECUTE_SUCCESS preprocessor tag inside each bad and good test file.  I will soon be adding auto-compile support for the tests to also check CPPOPS_CPPTYPES functionality as well.


STEP 7.  Make A Pull Request On Github

Before submitting a pull request on Github, please make sure your development branch or fork is up to date and compatible with the latest Github master branch.
