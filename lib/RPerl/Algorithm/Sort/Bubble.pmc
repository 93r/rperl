# [[[ HEADER ]]]
package RPerl::Algorithm::Sort::Bubble;
use strict;
use warnings;
use RPerl;
our $VERSION = 0.004_030;

# [[[ OO INHERITANCE ]]]
use parent qw( RPerl::Algorithm::Sort );
use RPerl::Algorithm::Sort;

# [[[ CRITICS ]]]
## no critic qw(ProhibitUselessNoCritic ProhibitMagicNumbers RequireCheckedSyscalls)
## no critic qw(RequireInterpolationOfMetachars)

# [[[ INCLUDES ]]]
use Data::Dumper;

# [[[ OO PROPERTIES ]]]
our hashref $properties = {
    integer_data => my integer_arrayref $TYPED_integer_data = undef,
    number_data  => my number_arrayref $TYPED_number_data   = undef
};

# [[[ OO METHODS & SUBROUTINES ]]]
our void_method $integer_sort = sub {
    ( my object $self ) = @_;
    $self->{integer_data} = integer_bubblesort( $self->{integer_data} );
};

our void_method $number_sort = sub {
    ( my object $self ) = @_;
    $self->{number_data} = number_bubblesort( $self->{number_data} );
};

our void_method $inherited__Bubble = sub {
    ( my object $self, my string $person ) = @_;
};

our void_method $inherited = sub {
    ( my object $self, my string $person ) = @_;
};

our integer_arrayref $integer_bubblesort = sub {
    ( my integer_arrayref $integer_data ) = @_;
    ::integer_arrayref_CHECKTRACE( $integer_data, '$integer_data',
        'integer_bubblesort()' );
    my integer $is_sorted           = 0;
    my integer $integer_data_length = scalar @{$integer_data};
    my integer $integer_data_i;
    my integer $integer_data_i_plus_1;
    my integer $swap;

LOOP_OUTER:
    while ( not($is_sorted) ) {
        $is_sorted = 1;

    LOOP_INNER:
        for my integer $i ( 0 .. ( $integer_data_length - 2 ) ) {
            $integer_data_i = $integer_data->[$i];
            $integer_data_i_plus_1 = $integer_data->[ ( $i + 1 ) ];
            if ( $integer_data_i > $integer_data_i_plus_1 ) {
                $is_sorted          = 0;
                $swap               = $integer_data_i;
                $integer_data->[$i] = $integer_data_i_plus_1;
                $integer_data->[ ( $i + 1 ) ] = $swap;
            }
        }
    }
    return $integer_data;
};

our number_arrayref $number_bubblesort = sub {
    ( my number_arrayref $number_data ) = @_;
    ::number_arrayref_CHECKTRACE( $number_data, '$number_data',
        'number_bubblesort()' );
    my integer $is_sorted          = 0;
    my integer $number_data_length = scalar @{$number_data};
    my integer $number_data_i;
    my integer $number_data_i_plus_1;
    my integer $swap;

LOOP_OUTER:
    while ( not($is_sorted) ) {
        $is_sorted = 1;

    LOOP_INNER:
        for my integer $i ( 0 .. ( $number_data_length - 2 ) ) {
            $number_data_i = $number_data->[$i];
            $number_data_i_plus_1 = $number_data->[ ( $i + 1 ) ];
            if ( $number_data_i > $number_data_i_plus_1 ) {
                $is_sorted         = 0;
                $swap              = $number_data_i;
                $number_data->[$i] = $number_data_i_plus_1;
                $number_data->[ ( $i + 1 ) ] = $swap;
            }
        }
    }
    return $number_data;
};

our string $uninherited__Bubble = sub {
    ( my string $person ) = @_;
    return ('Bubble::uninherited__Bubble() RULES! PERLOPS_PERLTYPES');
};

our string $uninherited = sub {
    ( my string $person ) = @_;
    return ('Bubble::uninherited() ROCKS! PERLOPS_PERLTYPES');
};

our string $integer_bubblesort__typetest0 = sub {
    ( my integer_arrayref $lucky_integers ) = @_;
    ::integer_arrayref_CHECKTRACE( $lucky_integers, '$lucky_integers',
        'integer_bubblesort__typetest0()' );
    return (
        ::integer_arrayref_to_string( integer_bubblesort($lucky_integers) )
            . 'PERLOPS_PERLTYPES' );
};

our string $number_bubblesort__typetest0 = sub {
    ( my number_arrayref $lucky_numbers ) = @_;
    ::number_arrayref_CHECKTRACE( $lucky_numbers, '$lucky_numbers',
        'number_bubblesort__typetest0()' );
    return ( ::number_arrayref_to_string( number_bubblesort($lucky_numbers) )
            . 'PERLOPS_PERLTYPES' );
};

1;    # end of class
